import soot.*;
import soot.jimple.*; 
import soot.jimple.AssignStmt;
import soot.jimple.IfStmt;
import soot.options.Options;
import soot.toolkits.graph.Block;
import soot.toolkits.graph.BlockGraph;
import soot.toolkits.graph.BriefBlockGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.jimple.toolkits.callgraph.Targets;
import soot.jimple.toolkits.callgraph.Sources;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.*;
import soot.jimple.toolkits.annotation.callgraph.CallGraphGrapher;
import soot.tagkit.LineNumberTag;
import soot.jimple.internal.InvokeExprBox;
import soot.jimple.internal.RValueBox;
import soot.jimple.internal.*;

import soot.Type;

import soot.jimple.ThisRef;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Test {
	public static void main(String[] args) {
		// Get Main Method

		String classPath = args[0];
		configureSoot(classPath);

		SootClass sootClass = Scene.v().loadClassAndSupport(args[1]);
		sootClass.setApplicationClass();
		Scene.v().loadNecessaryClasses();

		CHATransformer.v().transform();

		CallGraph cg = Scene.v().getCallGraph();
		SootMethod sm = Scene.v().getMainMethod();

		ArrayList<String> historyLocList = new ArrayList<String>();
		
		String confClass = "org.apache.hadoop.conf.Configuration";
		String confType = "getInt";
		String confName = "\"dfs.replication\"";

		sm = Scene.v().getSootClass(confClass).getMethodByName(confType);

		Iterator sources = new Sources(cg.edgesInto(sm));
		while (sources.hasNext()) {
			SootMethod sourceMethod = (SootMethod)sources.next();
			//ArrayList<Type> sourceArguments = new ArrayList<Type>(sourceMethod.getParameterTypes());
			//for (Type t : sourceArguments) {
			//	System.out.println(t);
			//}	

			Body sourceBody = sourceMethod.getActiveBody();
			List<ValueBox> usedValues = sourceBody.getUseBoxes();
			for (Unit unit : sourceBody.getUnits()) {
				for (ValueBox valueBox : unit.getUseBoxes()) {
					String invokeString = valueBox.getValue().toString();
					if (invokeString.contains(confClass) && invokeString.contains(confType) && invokeString.contains(confName)) {
						String historyString = sourceMethod + "@Line" + unit.getTags().get(0);
						if (!historyLocList.contains(historyString)) {
							System.out.println("----------------------");
							System.out.println(unit);
							System.out.println(historyString);
							Value definedValue = unit.getDefBoxes().get(0).getValue();
							System.out.println("Define:" + definedValue);
							findUsedVariables(definedValue, sourceBody.getUnits());
							//findUsedVariables(null, sourceBody);
							historyLocList.add(historyString);
							//System.out.println(sourceBody);
						}
					}
				}
			}
		}

		findClassField(null, null);
	}

	public static void findUsedVariables(Value definedValue, PatchingChain<Unit> sourceUnits) {
		for (Unit u : sourceUnits) {
			for (ValueBox v : u.getUseBoxes()) {
				if (v.getValue().equals(definedValue)) {
					System.out.println("The defined value is used by " + u.getDefBoxes().get(0).getValue());
					System.out.println(u);
					return;
				}
			}
		}

		System.out.println("The defined value is not used by other variables.");
		return ;
	}

	public static void findLocalVariable() {
	}

	public static void findFunctionCall() {
	}

	public static void findClassField(String className, String field) {
		SootMethod sm = Scene.v().getMainMethod();
		Iterator targets = new Targets(cg.edgesOutOf(sm));
		while(targets.hasNext()) {
			SootMethod target = (SootMethod)targets.next();
			System.out.println(target.getLocals());
		}
	}

	/*
	public static void findConfGet(SootMethod sm, CallGraph cg, String res, ArrayList<String> history) {
		//if (sm.getName().equals("getLong")) {
		if (sm.getName().contains("getLong")) {
			System.out.println(res);
			//System.out.println((LineNumberTag)sm.getTag("LineNumberTag"));
			return;
		}

		//System.out.println(res);
		Iterator targets = new Targets(cg.edgesOutOf(sm));
		while (targets.hasNext()) {
			SootMethod target = (SootMethod)targets.next();
			//if (target == null) continue;
			String targetName = target.getDeclaringClass().getName() + "|" + target.getName();
			if (history.contains(targetName) || targetName.contains("java.") || targetName.contains("javax.")) continue;
			history.add(targetName);
			findConfGet(target, cg, res +" -> " + targetName, history);
			history.remove(history.size()-1);
		}
	}
	*/

	private static void configureSoot(String classpath) {
		Options.v().set_whole_program(true);  // process whole program
		Options.v().set_allow_phantom_refs(true); // load phantom references
		Options.v().set_prepend_classpath(true); // prepend class path
		Options.v().set_src_prec(Options.src_prec_class); // process only .class files
		ArrayList<String> list = new ArrayList<>();
		list.add(classpath);
		//list.add("/mnt/git/hadoop-3.1.2-src/hadoop-common-project/hadoop-common/target/classes");
		Options.v().set_process_dir(list); // process all .class files in directory
		Options.v().setPhaseOption("cg.spark", "on"); // use spark for call graph
		Options.v().set_output_dir("/tmp/sootOutput"); // use spark for call graph
		Options.v().set_keep_line_number(true);
	}
}
